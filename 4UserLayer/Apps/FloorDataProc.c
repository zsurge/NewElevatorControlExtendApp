/******************************************************************************

                  版权所有 (C), 2013-2023, 深圳博思高科技有限公司

 ******************************************************************************
  文 件 名   : FloorDataProc.c
  版 本 号   : 初稿
  作    者   : 张舵
  生成日期   : 2019年12月23日
  最近修改   :
  功能描述   : 电梯控制器的指令处理文件
  函数列表   :
  修改历史   :
  1.日    期   : 2019年12月23日
    作    者   : 张舵
    修改内容   : 创建文件

******************************************************************************/

/*----------------------------------------------*
 * 包含头文件                                   *
 *----------------------------------------------*/
#define LOG_TAG    "FloorData"
#include "elog.h"
#include "FloorDataProc.h"

/*----------------------------------------------*
 * 宏定义                                       *
 *----------------------------------------------*/
#define AUTO_REG            1
#define MANUAL_REG          2

/*----------------------------------------------*
 * 常量定义                                     *
 *----------------------------------------------*/

/*----------------------------------------------*
 * 模块级变量                                   *
 *----------------------------------------------*/
ELEVATOR_BUFF_STRU gElevtorData,gRecvElevtorData;


/*----------------------------------------------*
 * 内部函数原型说明                             *
 *----------------------------------------------*/



void sendQueueToDev(ELEVATOR_BUFF_STRU *devSendData)
{
    /* 使用消息队列实现指针变量的传递 */
    if(xQueueSend(xTransDataQueue,              /* 消息队列句柄 */
               (void *)&devSendData,   /* 发送指针变量recv_buf的地址 */
               (TickType_t)50) != pdPASS )
    {
        log_d("the queue is full!\r\n");                
        xQueueReset(xTransDataQueue);
    } 

    else
    {
       log_d("devSendData->type = %d\r\n",devSendData->type);
       dbh("send  Queue  To Dev Data",devSendData->data,sizeof(devSendData->data));
    }


}

SYSERRORCODE_E packetToElevatorExtend(USERDATA_STRU *localUserData,ELEVATOR_BUFF_STRU *devSendData)
{     
    SYSERRORCODE_E result = NO_ERR;
    char authLayer[64] = {0}; //权限楼层，最多64层
    int num = 0;       
    
    memcpy(authLayer,localUserData->accessFloor,FLOOR_ARRAY_LEN);
    
    num = strlen((const char*)authLayer);

    log_d("localUserData->accessFloor num = %d\r\n",num);
    dbh("authLayer",authLayer,num);

   
    if(num > 1)//多层权限，手动
    {
        result = calcMultilFloor((uint8_t *)authLayer,num,devSendData);
    }
    else    //单层权限，直接呼默认权限楼层，自动
    {
        if(localUserData->defaultFloor != authLayer[0])
        {
        
            log_d("defaultFloor != authLayer,%d,%d\r\n",localUserData->defaultFloor,authLayer[0]);
            localUserData->defaultFloor = authLayer[0];
        }   
        
	    if(localUserData->defaultFloor == 0)
	    {
	        return INVALID_FLOOR;//无效的楼层
	    }

	    log_d("localUserData->defaultFloor = %d\r\n",localUserData->defaultFloor);
	    
        result = calcSingleFloor(localUserData->defaultFloor,devSendData);         
    }   
   
#if 0

        if(localUserData->defaultFloor != authLayer[0])
        {
        

            log_d("defaultFloor != authLayer,%d,%d\r\n",localUserData->defaultFloor,authLayer[0]);
            localUserData->defaultFloor = authLayer[0];
        }   
        
	    if(localUserData->defaultFloor == 0)
	    {
	        return INVALID_FLOOR;//无效的楼层
	    }

	    log_d("localUserData->defaultFloor = %d\r\n",localUserData->defaultFloor);
	    
        result = calcSingleFloor(localUserData->defaultFloor,devSendData);            
#endif

    
    return result;
}



//第一位权限，第二位按键

//单层权限
SYSERRORCODE_E calcSingleFloor(uint8_t layer,ELEVATOR_BUFF_STRU *eBuf)
{
    uint8_t floor = 0;
    uint8_t offset = ((bsp_dipswitch_read()>>2) & 0x03);
    
    uint8_t tmp[71] = { 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0D };
    //{ 0x7E,0x55,0x53,0x5A,0x8D,0x4B,0x57,0xA1,0x00,0x00,0x00,0x00,0x02,0x01,0x04,0xBC,0x00,0x00,0x00,0x00,0x00,0x13,0x0C,0x1B,0x42,0x01,0x01,0x00,0x00,0x00,0x35,0x90,0x0D,0x01,0x0B,0x0C,0x16,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x29 };
//    uint8_t tmp[104] = { 0x7E,0x55,0x53,0x5A,0x8D,0x4B,0x57,0xA1,0x00,0x00,0x00,0x00,0x02,0x01,0x04,0xBC,0x00,0x00,0x00,0x00,0x00,0x13,0x0C,0x1B,0x42,0x01,0x01,0x00,0x00,0x00,0x00,0x00,0x05,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0D };


    if(layer > 200)
    {
        if(256-layer == offset)
        {
            floor = offset - (256-layer)+1;
        }
        else if(256-layer < offset)
        {
            floor = offset-(256-layer)+1;
        }
        else
        {
            floor = offset+1;
        }        
    }
    else
    {
        floor = layer + ((bsp_dipswitch_read()>>2) & 0x03); //根据拨码补偿楼层数
    }
    

    
    tmp[0] = floor;

    //这里需要校验值，校验算法不知道
    eBuf->type = 0x01;
    memcpy(eBuf->data,tmp,71);

    return NO_ERR;
}

//多层权限
SYSERRORCODE_E calcMultilFloor(uint8_t *floorBuf,uint8_t num,ELEVATOR_BUFF_STRU *eBuf)
{
    uint8_t i = 0;
    
    uint8_t tmpFloor = 0;
    uint8_t curFloor = 0;
    //需补偿的楼层
    uint8_t offset = ((bsp_dipswitch_read()>>2) & 0x03);

    uint8_t tmp[71] = { 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0D };
    //uint8_t tmp[104] = { 0x7E,0x55,0x53,0x5A,0x8D,0x4B,0x57,0xA1,0x00,0x00,0x00,0x00,0x02,0x00,0x04,0xBC,0x00,0x00,0x00,0x00,0x00,0x13,0x0C,0x1B,0x42,0x01,0x01,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0D };
//    uint8_t tmp[104] = {0x7E,0x55,0x53,0x5A,0x8D,0x4B,0x57,0xA1,0xAA,0xAA,0xAA,0xAA,0x02,0xAA,0x04,0xBC,0xAA,0xAA,0xAA,0xAA,0xAA,0x13,0x0C,0x1B,0x42,0x01,0x01,0xAA,0xAA,0xAA,0x01,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0x0D };

    uint8_t tmpFloorBuf[64] = {0};
    
    uint8_t muti = 0;
    uint8_t remp = 0;

    memcpy(tmpFloorBuf,floorBuf,num);

    for(i=0;i<num;i++)
    {
        if(tmpFloorBuf[i] > 200)
        {
            if(256-tmpFloorBuf[i] == offset)
            {
                tmpFloorBuf[i] = offset - (256-tmpFloorBuf[i])+1;
            }
            else if(256-tmpFloorBuf[i] < offset)
            {
                tmpFloorBuf[i] = offset-(256-tmpFloorBuf[i])+1;
            }
            else
            {
                tmpFloorBuf[i] = offset+1;
            }
        }        
        else
        {
            tmpFloorBuf[i] += ((bsp_dipswitch_read()>>2) & 0x03); //根据拨码补偿楼层数
        }
   }

    
    if(num%5 == 0)
    {

        muti = num / 5;
        remp = 0;
    }
    else
    {
        muti = num / 5;
        remp = num % 5;
    }

    if(remp == 0)
    {
        for(i=0;i<muti;i++)
        {
            memcpy(tmp+i*8,tmpFloorBuf+i*5,5);
            memcpy(tmp+i*8+5,"\x1\x0\x0",3);
        }
    }
    else
    {
        for(i=0;i<muti;i++)
        {
            memcpy(tmp+i*8,tmpFloorBuf+i*5,5);
            memcpy(tmp+i*8+5,"\x1\x0\x0",3);
        }

        memcpy(tmp+i*8,tmpFloorBuf+i*5,remp); 
        
    }

   //这里需要校验值，校验算法不知道
   if(num>=25)
   {
     eBuf->type = 3;  
   }
   else
   {
     eBuf->type = 0x00;   
   }
       
    memcpy(eBuf->data,tmp,71);


    return NO_ERR;
}





